import {
    collection,
    getDocs,
    addDoc,
    updateDoc,
    deleteDoc,
    doc,
    setDoc,
    query,
    where,
    onSnapshot
} from "firebase/firestore";
import { db } from "./firebaseConfig";
import { Product, Order, OrderStatus, User, UserWithPassword } from "../types";

// Collection Names
const COLLECTIONS = {
    PRODUCTS: 'products',
    ORDERS: 'orders',
    USERS: 'users'
};

export const firebaseService = {
    /**
     * PRODUCTS
     */
    async getProducts(): Promise<Product[]> {
        try {
            const querySnapshot = await getDocs(collection(db, COLLECTIONS.PRODUCTS));
            return querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as Product));
        } catch (error) {
            console.error("Error getting products:", error);
            return [];
        }
    },

    async saveProduct(product: Omit<Product, 'id'>): Promise<Product> {
        try {
            const docRef = await addDoc(collection(db, COLLECTIONS.PRODUCTS), product);
            return { id: docRef.id, ...product };
        } catch (error) {
            console.error("Error saving product:", error);
            throw error;
        }
    },

    async updateProduct(id: string, updates: Partial<Product>): Promise<void> {
        try {
            const docRef = doc(db, COLLECTIONS.PRODUCTS, id);
            await updateDoc(docRef, updates);
        } catch (error) {
            console.error("Error updating product:", error);
            throw error;
        }
    },

    async deleteProduct(id: string): Promise<void> {
        try {
            await deleteDoc(doc(db, COLLECTIONS.PRODUCTS, id));
        } catch (error) {
            console.error("Error deleting product:", error);
            throw error;
        }
    },

    /**
     * ORDERS
     */
    // Returns logic for real-time listener if needed in React component
    // Basic fetch for one-time use
    async getOrders(): Promise<Order[]> {
        try {
            const querySnapshot = await getDocs(collection(db, COLLECTIONS.ORDERS));
            return querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as Order));
        } catch (error) {
            console.error("Error getting orders:", error);
            return [];
        }
    },

    async saveOrder(order: Order): Promise<void> {
        try {
            // We use the order ID generated by the app as the doc ID for consistency
            // OR let Firestore generate it. Here I'll set specific ID if available, else auto.
            // Since our app generates 'ORD-' ids, lets use them as doc keys or just fields.
            // Using setDoc with custom ID is better for finding it later.
            await setDoc(doc(db, COLLECTIONS.ORDERS, order.id), order);
        } catch (error) {
            console.error("Error saving order:", error);
            throw error;
        }
    },

    async updateOrderStatus(orderId: string, status: OrderStatus): Promise<void> {
        try {
            const docRef = doc(db, COLLECTIONS.ORDERS, orderId);
            await updateDoc(docRef, { status });
        } catch (error) {
            console.error("Error updating order:", error);
            throw error;
        }
    },

    /**
     * USERS
     */
    async getUsers(): Promise<UserWithPassword[]> {
        try {
            const querySnapshot = await getDocs(collection(db, COLLECTIONS.USERS));
            return querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as UserWithPassword));
        } catch (error) {
            console.error("Error getting users:", error);
            return [];
        }
    },

    async saveUser(user: UserWithPassword): Promise<void> {
        try {
            // Check if email already exists
            const q = query(collection(db, COLLECTIONS.USERS), where("email", "==", user.email));
            const querySnapshot = await getDocs(q);
            if (!querySnapshot.empty) {
                throw new Error("Email already exists");
            }

            // Use user ID (likely 'admin-001' or similar) as doc ID
            await setDoc(doc(db, COLLECTIONS.USERS, user.id), user);
        } catch (error) {
            console.error("Error saving user:", error);
            throw error;
        }
    },

    async deleteUser(id: string): Promise<void> {
        try {
            if (id === 'admin-001') {
                throw new Error('Cannot delete main admin');
            }
            await deleteDoc(doc(db, COLLECTIONS.USERS, id));
        } catch (error) {
            console.error("Error deleting user:", error);
            throw error;
        }
    },

    // Seed Function
    async initializeData() {
        try {
            // Check products
            const productsSnapshot = await getDocs(collection(db, COLLECTIONS.PRODUCTS));
            if (productsSnapshot.empty) {
                console.log("Seeding products...");
                for (const p of INITIAL_PRODUCTS) {
                    // Using setDoc to preserve IDs if important, or addDoc
                    await setDoc(doc(db, COLLECTIONS.PRODUCTS, p.id), p);
                }
            }

            // Check admin
            const adminRef = doc(db, COLLECTIONS.USERS, DEFAULT_ADMIN.id);
            const adminSnap = await getDocs(query(collection(db, COLLECTIONS.USERS), where("id", "==", DEFAULT_ADMIN.id)));

            // Easier check: just try to get the specific doc if ID is known, or query
            // We used setDoc with ID for users, so valid check:
            // But actually getCurrentUser in app might fail if not logged in.
            // We just ensure the account exists in DB.
            // Let's use setDoc with merge to ensure it exists without overwriting if changed? 
            // Or just check if empty.
            const usersSnapshot = await getDocs(collection(db, COLLECTIONS.USERS));
            if (usersSnapshot.empty) {
                console.log("Seeding admin...");
                await setDoc(adminRef, DEFAULT_ADMIN);
            }
        } catch (e) {
            console.error("Initialization error:", e);
        }
    },

    // Seed Function (Run once manually if needed)
    async seedProducts(products: Product[]) {
        const existing = await this.getProducts();
        if (existing.length === 0) {
            console.log("Seeding products...");
            for (const p of products) {
                await this.saveProduct(p);
            }
        }
    },

    async seedAdmin(admin: UserWithPassword) {
        try {
            const docRef = doc(db, COLLECTIONS.USERS, admin.id);
            await setDoc(docRef, admin);
            console.log("Admin seeded");
        } catch (e) {
            console.error("Seed admin error", e);
        }
    }
};
