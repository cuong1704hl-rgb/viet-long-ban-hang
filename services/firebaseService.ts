import {
    collection,
    getDocs,
    addDoc,
    updateDoc,
    deleteDoc,
    doc,
    setDoc,
    query,
    where,
    onSnapshot
} from "firebase/firestore";
import { db } from "./firebaseConfig";
import { Product, Order, OrderStatus, User, UserWithPassword } from "../types";

// Collection Names
const COLLECTIONS = {
    PRODUCTS: 'products',
    ORDERS: 'orders',
    USERS: 'users'
};

// Initial Data
const INITIAL_PRODUCTS: Product[] = [
    { id: '1', name: 'iPhone 15 Pro Max', price: 29900000, description: 'Thiết kế Titan, chip A17 Pro siêu mạnh mẽ.', image: 'https://images.unsplash.com/photo-1695048133142-1a20484d2569?auto=format&fit=crop&q=80&w=800', category: 'Điện thoại', stock: 10 },
    { id: '2', name: 'MacBook Pro M3', price: 39900000, description: 'Hiệu năng đỉnh cao, màn hình Liquid Retina XDR.', image: 'https://images.unsplash.com/photo-1517336714731-489689fd1ca4?auto=format&fit=crop&q=80&w=800', category: 'Laptop', stock: 5 },
    { id: '3', name: 'AirPods Pro 2', price: 5900000, description: 'Chống ồn chủ động gấp 2 lần.', image: 'https://images.unsplash.com/photo-1628202926206-c63a34b1618f?auto=format&fit=crop&q=80&w=800', category: 'Phụ kiện', stock: 20 },
    { id: '4', name: 'Apple Watch Series 9', price: 9900000, description: 'Cảm biến sức khỏe tiên tiến nhất.', image: 'https://images.unsplash.com/photo-1546868871-7041f2a55e12?auto=format&fit=crop&q=80&w=800', category: 'Phụ kiện', stock: 15 },
    { id: '5', name: 'iPad Air M2', price: 16900000, description: 'Mỏng nhẹ, mạnh mẽ với chip M2.', image: 'https://images.unsplash.com/photo-1544244015-0df4b3ffc6b0?auto=format&fit=crop&q=80&w=800', category: 'Máy tính bảng', stock: 8 },
    { id: '6', name: 'Samsung Galaxy S24 Ultra', price: 27900000, description: 'Bút S-Pen tích hợp, camera 200MP.', image: 'https://images.unsplash.com/photo-1610945415295-d9bbf067e59c?auto=format&fit=crop&q=80&w=800', category: 'Điện thoại', stock: 12 },
    { id: '7', name: 'Dell XPS 15', price: 35900000, description: 'Laptop cao cấp cho dân chuyên nghiệp.', image: 'https://images.unsplash.com/photo-1593642632823-8f78536788c6?auto=format&fit=crop&q=80&w=800', category: 'Laptop', stock: 7 },
    { id: '8', name: 'Sony WH-1000XM5', price: 7900000, description: 'Tai nghe chống ồn hàng đầu thế giới.', image: 'https://images.unsplash.com/photo-1618366712010-f4ae9c647dcb?auto=format&fit=crop&q=80&w=800', category: 'Phụ kiện', stock: 25 }
];

const DEFAULT_ADMIN: UserWithPassword = {
    id: 'admin-001',
    email: 'admin@vietlong.com',
    name: 'Admin Việt Long',
    role: 'admin',
    createdAt: new Date().toISOString(),
    password: '240be518fabd2724ddb6f04eeb1da5967448d7e831c08c8fa822809f74c720a9'
};

export const firebaseService = {
    /**
     * PRODUCTS
     */
    async getProducts(): Promise<Product[]> {
        try {
            const querySnapshot = await getDocs(collection(db, COLLECTIONS.PRODUCTS));
            return querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as Product));
        } catch (error) {
            console.error("Error getting products:", error);
            return [];
        }
    },

    async saveProduct(product: Omit<Product, 'id'>): Promise<Product> {
        try {
            const docRef = await addDoc(collection(db, COLLECTIONS.PRODUCTS), product);
            return { id: docRef.id, ...product };
        } catch (error) {
            console.error("Error saving product:", error);
            throw error;
        }
    },

    async updateProduct(id: string, updates: Partial<Product>): Promise<void> {
        try {
            const docRef = doc(db, COLLECTIONS.PRODUCTS, id);
            await updateDoc(docRef, updates);
        } catch (error) {
            console.error("Error updating product:", error);
            throw error;
        }
    },

    async deleteProduct(id: string): Promise<void> {
        try {
            await deleteDoc(doc(db, COLLECTIONS.PRODUCTS, id));
        } catch (error) {
            console.error("Error deleting product:", error);
            throw error;
        }
    },

    /**
     * ORDERS
     */
    // Returns logic for real-time listener if needed in React component
    // Basic fetch for one-time use
    async getOrders(): Promise<Order[]> {
        try {
            const querySnapshot = await getDocs(collection(db, COLLECTIONS.ORDERS));
            return querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as Order));
        } catch (error) {
            console.error("Error getting orders:", error);
            return [];
        }
    },

    async saveOrder(order: Order): Promise<void> {
        try {
            // We use the order ID generated by the app as the doc ID for consistency
            // OR let Firestore generate it. Here I'll set specific ID if available, else auto.
            // Since our app generates 'ORD-' ids, lets use them as doc keys or just fields.
            // Using setDoc with custom ID is better for finding it later.
            await setDoc(doc(db, COLLECTIONS.ORDERS, order.id), order);
        } catch (error) {
            console.error("Error saving order:", error);
            throw error;
        }
    },

    async updateOrderStatus(orderId: string, status: OrderStatus): Promise<void> {
        try {
            const docRef = doc(db, COLLECTIONS.ORDERS, orderId);
            await updateDoc(docRef, { status });
        } catch (error) {
            console.error("Error updating order:", error);
            throw error;
        }
    },

    async deleteOrder(orderId: string): Promise<void> {
        try {
            await deleteDoc(doc(db, COLLECTIONS.ORDERS, orderId));
        } catch (error) {
            console.error("Error deleting order:", error);
            throw error;
        }
    },

    /**
     * USERS
     */
    async getUsers(): Promise<UserWithPassword[]> {
        try {
            const querySnapshot = await getDocs(collection(db, COLLECTIONS.USERS));
            return querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as UserWithPassword));
        } catch (error) {
            console.error("Error getting users:", error);
            return [];
        }
    },

    async saveUser(user: UserWithPassword): Promise<void> {
        try {
            // Check if email already exists
            const q = query(collection(db, COLLECTIONS.USERS), where("email", "==", user.email));
            const querySnapshot = await getDocs(q);
            if (!querySnapshot.empty) {
                throw new Error("Email already exists");
            }

            // Use user ID (likely 'admin-001' or similar) as doc ID
            await setDoc(doc(db, COLLECTIONS.USERS, user.id), user);
        } catch (error) {
            console.error("Error saving user:", error);
            throw error;
        }
    },

    async deleteUser(id: string): Promise<void> {
        try {
            if (id === 'admin-001') {
                throw new Error('Cannot delete main admin');
            }
            await deleteDoc(doc(db, COLLECTIONS.USERS, id));
        } catch (error) {
            console.error("Error deleting user:", error);
            throw error;
        }
    },

    // Seed Function
    async initializeData() {
        try {
            // Check products
            const productsSnapshot = await getDocs(collection(db, COLLECTIONS.PRODUCTS));
            if (productsSnapshot.empty) {
                console.log("Seeding products...");
                for (const p of INITIAL_PRODUCTS) {
                    // Using setDoc to preserve IDs if important, or addDoc
                    await setDoc(doc(db, COLLECTIONS.PRODUCTS, p.id), p);
                }
            }

            // Check admin
            const adminRef = doc(db, COLLECTIONS.USERS, DEFAULT_ADMIN.id);
            const adminSnap = await getDocs(query(collection(db, COLLECTIONS.USERS), where("id", "==", DEFAULT_ADMIN.id)));

            // Easier check: just try to get the specific doc if ID is known, or query
            // We used setDoc with ID for users, so valid check:
            // But actually getCurrentUser in app might fail if not logged in.
            // We just ensure the account exists in DB.
            // Let's use setDoc with merge to ensure it exists without overwriting if changed? 
            // Or just check if empty.
            const usersSnapshot = await getDocs(collection(db, COLLECTIONS.USERS));
            if (usersSnapshot.empty) {
                console.log("Seeding admin...");
                await setDoc(adminRef, DEFAULT_ADMIN);
            }
        } catch (e) {
            console.error("Initialization error:", e);
        }
    },

    // Seed Function (Run once manually if needed)
    async seedProducts(products: Product[]) {
        const existing = await this.getProducts();
        if (existing.length === 0) {
            console.log("Seeding products...");
            for (const p of products) {
                await this.saveProduct(p);
            }
        }
    },

    async seedAdmin(admin: UserWithPassword) {
        try {
            const docRef = doc(db, COLLECTIONS.USERS, admin.id);
            await setDoc(docRef, admin);
            console.log("Admin seeded");
        } catch (e) {
            console.error("Seed admin error", e);
        }
    }
};
